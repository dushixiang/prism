// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package internal

import (
	"github.com/dushixiang/prism/internal/config"
	"github.com/dushixiang/prism/internal/handler"
	"github.com/dushixiang/prism/internal/service"
	"github.com/dushixiang/prism/internal/telegram"
	"github.com/dushixiang/prism/pkg/exchange"
	"github.com/google/wire"
	"github.com/openai/openai-go"
	"github.com/openai/openai-go/option"
	"go.uber.org/zap"
	"gorm.io/gorm"
	"net/http"
	"net/url"
	"time"
)

// Injectors from wire.go:

// InitializeApp 初始化应用
func InitializeApp(logger *zap.Logger, db *gorm.DB, conf *config.Config) (*AppComponents, error) {
	binanceClient := provideBinanceClient(conf, logger)
	exchange := provideExchange(conf, binanceClient, logger)
	indicatorService := service.NewIndicatorService()
	marketService := service.NewMarketService(db, exchange, indicatorService, logger)
	tradingAccountService := service.NewTradingAccountService(db, exchange, logger)
	positionService := service.NewPositionService(db, exchange, logger)
	promptService := service.NewPromptService(db, conf)
	client := provideOpenAIClient(conf, logger)
	agentService := service.NewAgentService(db, client, exchange, positionService, logger, conf)
	tradingLoop := service.NewTradingLoop(conf, marketService, tradingAccountService, positionService, promptService, agentService, logger)
	tradingHandler := handler.NewTradingHandler(tradingLoop, tradingAccountService, positionService, agentService, logger)
	telegram := provideTelegram(logger, conf)
	appComponents := &AppComponents{
		TradingHandler:        tradingHandler,
		TradingLoop:           tradingLoop,
		MarketService:         marketService,
		TradingAccountService: tradingAccountService,
		PositionService:       positionService,
		AgentService:          agentService,
		tg:                    telegram,
	}
	return appComponents, nil
}

// wire.go:

const (
	telegramHTTPTimeout     = 10 * time.Second
	openaiProviderName      = "openai"
	logFieldMissingDeps     = "missing_dependencies"
	logFieldConfiguredModel = "model"
)

var (
	handlerSet = wire.NewSet(handler.NewTradingHandler)

	tradingSet = wire.NewSet(
		provideBinanceClient,
		provideExchange,
		provideOpenAIClient, service.NewIndicatorService, service.NewMarketService, service.NewTradingAccountService, service.NewPositionService, service.NewPromptService, service.NewAgentService, service.NewTradingLoop,
	)
)

// provideTelegram provides telegram instance
func provideTelegram(logger *zap.Logger, conf *config.Config) *telegram.Telegram {
	if !conf.Telegram.Enabled {
		return nil
	}

	httpClient := &http.Client{Timeout: telegramHTTPTimeout}

	tg, err := telegram.NewTelegram(logger, telegram.Settings{
		Token:  conf.Telegram.Token,
		Client: httpClient,
	})
	if err != nil {
		logger.Error("failed to init telegram", zap.Error(err))
		return nil
	}

	return tg
}

// provideBinanceClient provides Binance client (used by both real and paper trading)
func provideBinanceClient(conf *config.Config, logger *zap.Logger) *exchange.BinanceClient {
	client := exchange.NewBinanceClient(
		conf.Binance.APIKey,
		conf.Binance.Secret,
		conf.Binance.ProxyURL,
		conf.Binance.Testnet,
	)

	if conf.Binance.APIKey == "" || conf.Binance.Secret == "" {
		logger.Warn("Binance API credentials not configured; some private endpoints may fail")
	}

	logger.Info("Binance client initialized", zap.Bool("testnet", conf.Binance.Testnet), zap.Bool("has_credentials", conf.Binance.APIKey != "" && conf.Binance.Secret != ""))
	return client
}

// provideExchange provides Exchange interface based on configuration
func provideExchange(conf *config.Config, binanceClient *exchange.BinanceClient, logger *zap.Logger) exchange.Exchange {
	if conf.Trading.Enabled {

		logger.Info("Using real trading mode (Binance)")
		return binanceClient
	}

	initialBalance := conf.Trading.PaperWallet.InitialBalance
	if initialBalance <= 0 {
		initialBalance = 1000.0
		logger.Warn("Paper wallet initial balance not configured or invalid, using default", zap.Float64("default_balance", initialBalance))
	}

	logger.Info("Using paper trading mode (Paper Wallet)", zap.Float64("initial_balance", initialBalance))
	return exchange.NewPaperWallet(binanceClient, initialBalance, logger)
}

// provideOpenAIClient provides OpenAI client
func provideOpenAIClient(conf *config.Config, logger *zap.Logger) *openai.Client {
	var options = []option.RequestOption{option.WithBaseURL(conf.LLM.BaseURL), option.WithAPIKey(conf.LLM.APIKey)}
	if conf.LLM.ProxyURL != "" {
		u, err := url.Parse(conf.LLM.ProxyURL)
		if err != nil {
			logger.Fatal("failed to parse proxy URL", zap.Error(err))
		}
		httpClient := &http.Client{
			Timeout: time.Minute,
			Transport: &http.Transport{
				Proxy: http.ProxyURL(u),
			},
		}
		options = append(options, option.WithHTTPClient(httpClient))
	}

	client := openai.NewClient(options...)

	logger.Info("OpenAI client initialized", zap.String(logFieldConfiguredModel, conf.LLM.Model), zap.String("provider", openaiProviderName))
	return &client
}
